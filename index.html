<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Real-Time Multi-threaded Application Simulator</title>
<style>
  :root{
    --bg:#0f1724; --card:#0b1220; --muted:#9aa7bf; --accent:#6ee7b7;
    --danger:#ff6b6b; --yellow:#ffd166; --glass: rgba(255,255,255,0.04);
    --tile-size:18px;
    font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
  }
  *{box-sizing:border-box}
  body{margin:0;background:linear-gradient(180deg,#071021 0%, #0f1724 100%);color:#e6eef6;min-height:100vh;display:flex;flex-direction:column}
  header{padding:18px 20px;display:flex;align-items:center;gap:16px;border-bottom:1px solid rgba(255,255,255,0.04)}
  header h1{font-size:18px;margin:0}
  header .meta{font-size:13px;color:var(--muted)}
  .wrap{display:grid;grid-template-columns:320px 1fr 360px;gap:16px;padding:16px;align-items:start}
  /* responsive */
  @media (max-width:1100px){ .wrap{grid-template-columns:1fr; padding:12px} .right, .left{order:99} .center{order:1} }
  /* cards */
  .card{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border-radius:12px;padding:12px;border:1px solid rgba(255,255,255,0.03);box-shadow:0 6px 24px rgba(2,6,23,0.6)}
  .left .card, .right .card{margin-bottom:12px}
  label{font-size:13px;color:var(--muted);display:block;margin-bottom:6px}
  input, select, button{font-size:14px;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:transparent;color:inherit}
  .row{display:flex;gap:8px;align-items:center}
  button.primary{background:linear-gradient(90deg,#22c1c3,#6ee7b7);border:none;color:#062122;font-weight:600}
  button.warn{background:linear-gradient(90deg,#ff8a65,#ff6b6b);border:none;color:white}
  .controls{display:flex;flex-direction:column;gap:8px}
  .small{font-size:12px;color:var(--muted)}
  /* center visualization */
  .center{display:flex;flex-direction:column;gap:12px}
  .toolbar{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  .lanes{background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.005));padding:12px;border-radius:10px;min-height:200px;overflow:auto}
  .thread-row{display:flex;gap:8px;align-items:center;padding:6px;border-radius:8px;margin-bottom:6px}
  .thread-label{width:90px;font-weight:700;color:#cfeef0}
  .tiles{display:flex;gap:3px;flex-wrap:nowrap;min-width:120px;overflow:auto;padding:4px}
  .tile{width:var(--tile-size);height:var(--tile-size);border-radius:4px;flex:0 0 auto;box-shadow:inset 0 -1px 0 rgba(0,0,0,0.2)}
  .state-Running{background:#22c1c3}
  .state-Ready{background:#ffd166}
  .state-Blocked{background:#ff6b6b}
  .state-Terminated{background:#94a3b8}
  .state-New{background:#7c3aed}
  .cpu-box{display:flex;gap:8px;align-items:center;padding:8px;border-radius:8px;background:linear-gradient(90deg, rgba(255,255,255,0.01), rgba(255,255,255,0.005))}
  .cpu-slot{flex:1;padding:8px;border-radius:8px;border:1px dashed rgba(255,255,255,0.04);text-align:center;font-size:13px}
  .log{max-height:240px;overflow:auto;padding:8px;background:rgba(0,0,0,0.12);border-radius:8px;border:1px solid rgba(255,255,255,0.02)}
  .muted{color:var(--muted);font-size:13px}
  .sep{height:1px;background:rgba(255,255,255,0.02);margin:8px 0;border-radius:4px}
  /* right panel */
  .resource{display:flex;flex-direction:column;gap:8px}
  .resource div{display:flex;justify-content:space-between;align-items:center;padding:6px;border-radius:8px;background:var(--glass)}
  .badge{padding:6px 8px;border-radius:999px;background:rgba(255,255,255,0.03);font-weight:600}
  .grid-2{display:grid;grid-template-columns:1fr 1fr;gap:8px}
  .footer{padding:12px;margin-top:auto;color:var(--muted);font-size:13px;text-align:center}
  /* responsiveness for tiles scrollbars */
  .tiles::-webkit-scrollbar{height:8px}
  .tiles::-webkit-scrollbar-thumb{background:rgba(0,0,0,0.3);border-radius:8px}
  /* small screens adjustments */
  @media (max-width:600px){
    .thread-label{width:70px;font-size:13px}
    .badge{font-size:12px;padding:4px 6px}
  }
</style>
</head>
<body>
<header>
  <div style="display:flex;flex-direction:column">
    <h1>Real-Time Multi-threaded Application Simulator</h1>
    <div class="meta">Kumar Abhinash (12501247) â€¢ Ajay Upadhyay (12528614) â€¢ Lovely Professional University</div>
  </div>
</header>

<div class="wrap">
  <!-- LEFT: Controls -->
  <div class="left">
    <div class="card">
      <label>Threading Model</label>
      <div class="row">
        <select id="modelSelect">
          <option>Many-to-One</option>
          <option>One-to-One</option>
          <option>Many-to-Many</option>
        </select>
        <label style="margin-left:6px" class="small">Scheduler</label>
        <select id="schedSelect" style="margin-left:6px">
          <option>RoundRobin</option>
          <option>FCFS</option>
          <option>Priority</option>
        </select>
      </div>

      <div class="sep"></div>

      <label>Create Thread</label>
      <div class="row" style="gap:6px">
        <input id="burstInput" type="number" placeholder="Burst (ticks)" value="6" style="width:120px" />
        <input id="prioInput" type="number" placeholder="Priority" value="1" style="width:90px" />
      </div>
      <div style="display:flex;gap:8px;margin-top:8px">
        <button id="addThreadBtn" class="primary">Add Thread</button>
        <button id="addRandomBtn">Add Random</button>
      </div>

      <div class="sep"></div>

      <label>Synchronization</label>
      <div class="row" style="gap:6px;margin-bottom:6px">
        <input id="sname" placeholder="Semaphore name" value="S1" style="width:120px" />
        <input id="sinit" type="number" placeholder="Init" value="1" style="width:70px" />
        <button id="createSema">Create</button>
      </div>
      <div class="row" style="gap:6px">
        <input id="mname" placeholder="Monitor name" value="M1" style="width:120px" />
        <button id="createMon">Create Monitor</button>
      </div>

      <div class="sep"></div>

      <label>Simulation Controls</label>
      <div class="row" style="margin-bottom:6px">
        <button id="playBtn" class="primary">Play</button>
        <button id="pauseBtn">Pause</button>
        <button id="stepBtn">Step</button>
        <button id="resetBtn" class="warn">Reset</button>
      </div>
      <div class="row" style="align-items:center;margin-top:8px">
        <label class="small">Quantum (ms)</label>
        <input id="quantum" type="number" value="300" style="width:100px;margin-left:6px" />
        <label class="small" style="margin-left:8px">Speed</label>
        <input id="speed" type="range" min="80" max="1000" value="300" style="flex:1;margin-left:6px" />
      </div>

      <div class="sep"></div>

      <label>Presets</label>
      <div style="display:flex;gap:8px;flex-wrap:wrap">
        <button id="preset1">Many-to-One Demo</button>
        <button id="preset2">Semaphore Pool</button>
        <button id="preset3">Producer/Consumer</button>
      </div>
    </div>

    <div class="card">
      <label>Save / Load Scenario</label>
      <div class="row" style="margin-bottom:8px">
        <button id="exportBtn">Export JSON</button>
        <input id="importFile" type="file" accept=".json" />
      </div>
      <div class="sep"></div>
      <label>Quick Tips</label>
      <ul class="small" style="margin:8px 0 0 18px;padding:0">
        <li>Use Step to debug tick-by-tick</li>
        <li>Use Many-to-One to see process-wide blocking</li>
        <li>Use semaphores to create realistic blocking</li>
      </ul>
    </div>

  </div>

  <!-- CENTER: Visualization -->
  <div class="center">
    <div class="card toolbar">
      <div style="display:flex;gap:12px;align-items:center;flex:1">
        <div><strong>Simulation</strong></div>
        <div class="muted">Tick: <span id="tickCounter">0</span></div>
        <div class="muted">Threads: <span id="countThreads">0</span></div>
        <div class="muted">Kernel threads: <span id="countKernel">0</span></div>
      </div>
      <div style="display:flex;gap:8px;align-items:center">
        <button id="clearLogs">Clear Logs</button>
      </div>
    </div>

    <div class="card lanes" id="lanesContainer" aria-live="polite">
      <!-- thread rows inserted here -->
      <div id="cpuArea" style="margin-bottom:12px">
        <label class="small" style="margin-bottom:6px;display:block">CPU / Kernel Threads</label>
        <div id="cpuSlots" class="cpu-box"></div>
      </div>

      <div id="threadsList"></div>
    </div>

    <div class="card">
      <label>Gantt (recent ticks)</label>
      <div class="muted" style="font-size:13px;margin-bottom:8px">Colors: ðŸŸ¢ Running â€¢ ðŸŸ¡ Ready â€¢ ðŸ”´ Blocked â€¢ âšª Terminated</div>
      <div id="logArea" class="log"></div>
    </div>
  </div>

  <!-- RIGHT: Resources & Info -->
  <div class="right">
    <div class="card">
      <label>Semaphores</label>
      <div id="semaList" class="resource"></div>
      <div class="sep"></div>
      <label>Monitors</label>
      <div id="monList" class="resource"></div>
    </div>

    <div class="card">
      <label>Thread Controls</label>
      <div id="threadControls" class="grid-2"></div>
    </div>

    <div class="card">
      <label>Event Log</label>
      <div id="events" class="log"></div>
    </div>
  </div>
</div>

<div class="footer card" style="margin:12px 16px">
  <div style="font-weight:700">Made for: Real-Time Multi-threaded Application Simulator</div>
  <div class="muted">Demonstrates thread models, scheduling, semaphores, and monitors â€” fully client-side.</div>
</div>

<script>
/*
  Real-Time Multi-threaded Application Simulator
  Single-file HTML/CSS/JS educational simulator.
*/

/* -------------------------
   Simulation Data Structures
   ------------------------- */
let nextTid = 1;
let tick = 0;
let running = false;
let timer = null;
let quantum = 300;
let model = 'Many-to-One';
let scheduler = 'RoundRobin';
let kernelThreads = 1; // for mapping pool in Many-to-Many
const threads = []; // user threads
const semaphores = {}; // {name: {value, queue:[]}}
const monitors = {}; // {name: {locked:false, owner:null, waitq:[]}}
const events = [];

/* Thread object:
  {
    id, state, burstRemaining, priority, history[], waitingFor: {type:'sema'|'monitor', name}
  }
*/

/* -------------------------
   Helpers & UI references
   ------------------------- */
const lanesEl = document.getElementById('threadsList');
const cpuSlotsEl = document.getElementById('cpuSlots');
const logEl = document.getElementById('logArea');
const eventsEl = document.getElementById('events');

function logEvent(msg){
  const time = tick;
  events.unshift(`[t=${time}] ${msg}`);
  if(events.length>200) events.pop();
  eventsEl.innerHTML = events.map(s=>`<div>${s}</div>`).join('');
}

/* -------------------------
   Simulation Engine
   ------------------------- */
function makeThread(burst=5, priority=1, name=null){
  const t = {
    id: nextTid++,
    name: name || `T${nextTid-1}`,
    state: 'Ready', // New, Ready, Running, Blocked, Terminated
    burstRemaining: burst,
    priority: priority,
    history: [],
    waitingFor: null,
    kernelSlot: null
  };
  threads.push(t);
  renderUI();
  logEvent(`Created ${t.name} (burst=${burst}, prio=${priority})`);
  return t;
}

function resetAll(){
  nextTid = 1;
  tick = 0;
  running = false;
  clearInterval(timer);
  timer = null;
  threads.length = 0;
  for(const k in semaphores) delete semaphores[k];
  for(const k in monitors) delete monitors[k];
  events.length = 0;
  renderUI();
  renderResources();
  updateStats();
}

function findReady(){
  return threads.filter(t=>t.state==='Ready');
}

function schedulerPick(){
  const ready = findReady();
  if(ready.length===0) return null;
  if(scheduler === 'FCFS') return ready[0];
  if(scheduler === 'Priority') {
    ready.sort((a,b)=> b.priority - a.priority || a.id - b.id);
    return ready[0];
  }
  // RoundRobin simulation: rotate by last run - we'll pick first ready to be simple
  return ready[0];
}

/* Apply model consequences when blocking occurs */
function applyModelOnBlock(blockingThread){
  if(model === 'Many-to-One'){
    // simulate entire process blocking: set non-terminated threads to Blocked
    threads.forEach(t=>{
      if(t.state !== 'Terminated'){
        if(t.id === blockingThread.id){
          t.state = 'Blocked';
          t.waitingFor = blockingThread.waitingFor;
        } else {
          if(t.state !== 'Terminated') t.state = 'Blocked';
        }
      }
    });
    logEvent(`(M2O) Process blocked due to ${blockingThread.name} waiting for ${blockingThread.waitingFor.type}:${blockingThread.waitingFor.name}`);
  } else if(model === 'One-to-One'){
    // only thread blocked -> handled elsewhere
  } else if(model === 'Many-to-Many'){
    // blocked thread returns kernel slot (if any)
    if(blockingThread.kernelSlot !== null){
      // free kernel slot
      blockingThread.kernelSlot = null;
      renderCPUSlots();
    }
  }
}



/* -------------------------
   Tick / run loop
   ------------------------- */
function tickOnce(){
  tick++;
  document.getElementById('tickCounter').textContent = tick;
  // choose running threads per kernel capacity (for One-to-One maybe each user thread can run -> but sim limited)
  // We'll maintain kernelSlots count:
  let activeKernel = (model==='One-to-One') ? threads.filter(t=>t.state==='Ready' || t.state==='Running').length : (model==='Many-to-Many' ? Math.max(1, kernelThreads) : 1);
  // ensure activeKernel limit reasonable
  activeKernel = Math.min(activeKernel, 10);

  // if model is Many-to-One, only one can be running
  if(model === 'Many-to-One') activeKernel = 1;

  // get eligible threads for running (Ready)
  let runCandidates = threads.filter(t=>t.state==='Running' || t.state==='Ready');

  // If nothing to run, just add histories
  if(runCandidates.length === 0){
    threads.forEach(t=>{
      t.history.push(t.state);
      if(t.history.length>120) t.history.shift();
    });
    renderUI();
    return;
  }

  // assign running slots (simple):
  // 1) If someone is already Running, let them finish quantum (simulate by making them run one tick)
  // 2) Else pick by scheduler
  let runningNow = threads.filter(t=>t.state==='Running');
  if(runningNow.length < activeKernel){
    // fill slots
    while(runningNow.length < activeKernel){
      const pick = schedulerPick();
      if(!pick) break;
      pick.state = 'Running';
      runningNow.push(pick);
    }
  }

  // Execute work for running threads (1 unit)
  for(const t of threads){
    // history before update
    t.history.push(t.state);
    if(t.history.length>120) t.history.shift();
  }

  // copy running threads and process
  const toProcess = threads.filter(t=>t.state==='Running');
  for(const t of toProcess){
    // simulate performing 1 unit
    t.burstRemaining--;
    // random demo: some running threads attempt to acquire semaphores/monitors (disabled by default in stable)
    // If we want deterministic, comment randomness.
    // If burst completes
    if(t.burstRemaining <= 0){
      t.state = 'Terminated';
      t.waitingFor = null;
      logEvent(`${t.name} terminated`);
    } else {
      // For fairness/slice: put back to Ready for RR
      if(scheduler === 'RoundRobin'){
        t.state = 'Ready';
      } else {
        // FCFS or Priority will keep them Running until others
        t.state = 'Ready';
      }
    }
  }

  // occasionally auto-signal semaphores to show progress (demo)
  for(const name in semaphores){
    const s = semaphores[name];
    // if a queue exists and value==0, try to release occasionally
    if(s.queue.length > 0 && Math.random() < 0.05){
      sem_signal(name);
    }
  }
  // also try to release monitors occasionally for demo
  for(const name in monitors){
    const m = monitors[name];
    if(m.locked && Math.random() < 0.04){
      monitor_exit(name);
    }
  }

  renderUI();
  updateStats();
}


</script>
</body>
</html>
