<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Real-Time Multi-threaded Application Simulator</title>
<style>
  :root{
    --bg:#0f1724; --card:#0b1220; --muted:#9aa7bf; --accent:#6ee7b7;
    --danger:#ff6b6b; --yellow:#ffd166; --glass: rgba(255,255,255,0.04);
    --tile-size:18px;
    font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
  }
  *{box-sizing:border-box}
  body{margin:0;background:linear-gradient(180deg,#071021 0%, #0f1724 100%);color:#e6eef6;min-height:100vh;display:flex;flex-direction:column}
  header{padding:18px 20px;display:flex;align-items:center;gap:16px;border-bottom:1px solid rgba(255,255,255,0.04)}
  header h1{font-size:18px;margin:0}
  header .meta{font-size:13px;color:var(--muted)}
  .wrap{display:grid;grid-template-columns:320px 1fr 360px;gap:16px;padding:16px;align-items:start}
  /* responsive */
  @media (max-width:1100px){ .wrap{grid-template-columns:1fr; padding:12px} .right, .left{order:99} .center{order:1} }
  /* cards */
  .card{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border-radius:12px;padding:12px;border:1px solid rgba(255,255,255,0.03);box-shadow:0 6px 24px rgba(2,6,23,0.6)}
  .left .card, .right .card{margin-bottom:12px}
  label{font-size:13px;color:var(--muted);display:block;margin-bottom:6px}
  input, select, button{font-size:14px;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:transparent;color:inherit}
  .row{display:flex;gap:8px;align-items:center}
  button.primary{background:linear-gradient(90deg,#22c1c3,#6ee7b7);border:none;color:#062122;font-weight:600}
  button.warn{background:linear-gradient(90deg,#ff8a65,#ff6b6b);border:none;color:white}
  .controls{display:flex;flex-direction:column;gap:8px}
  .small{font-size:12px;color:var(--muted)}
  /* center visualization */
  .center{display:flex;flex-direction:column;gap:12px}
  .toolbar{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  .lanes{background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.005));padding:12px;border-radius:10px;min-height:200px;overflow:auto}
  .thread-row{display:flex;gap:8px;align-items:center;padding:6px;border-radius:8px;margin-bottom:6px}
  .thread-label{width:90px;font-weight:700;color:#cfeef0}
  .tiles{display:flex;gap:3px;flex-wrap:nowrap;min-width:120px;overflow:auto;padding:4px}
  .tile{width:var(--tile-size);height:var(--tile-size);border-radius:4px;flex:0 0 auto;box-shadow:inset 0 -1px 0 rgba(0,0,0,0.2)}
  .state-Running{background:#22c1c3}
  .state-Ready{background:#ffd166}
  .state-Blocked{background:#ff6b6b}
  .state-Terminated{background:#94a3b8}
  .state-New{background:#7c3aed}
  .cpu-box{display:flex;gap:8px;align-items:center;padding:8px;border-radius:8px;background:linear-gradient(90deg, rgba(255,255,255,0.01), rgba(255,255,255,0.005))}
  .cpu-slot{flex:1;padding:8px;border-radius:8px;border:1px dashed rgba(255,255,255,0.04);text-align:center;font-size:13px}
  .log{max-height:240px;overflow:auto;padding:8px;background:rgba(0,0,0,0.12);border-radius:8px;border:1px solid rgba(255,255,255,0.02)}
  .muted{color:var(--muted);font-size:13px}
  .sep{height:1px;background:rgba(255,255,255,0.02);margin:8px 0;border-radius:4px}
  /* right panel */
  .resource{display:flex;flex-direction:column;gap:8px}
  .resource div{display:flex;justify-content:space-between;align-items:center;padding:6px;border-radius:8px;background:var(--glass)}
  .badge{padding:6px 8px;border-radius:999px;background:rgba(255,255,255,0.03);font-weight:600}
  .grid-2{display:grid;grid-template-columns:1fr 1fr;gap:8px}
  .footer{padding:12px;margin-top:auto;color:var(--muted);font-size:13px;text-align:center}
  /* responsiveness for tiles scrollbars */
  .tiles::-webkit-scrollbar{height:8px}
  .tiles::-webkit-scrollbar-thumb{background:rgba(0,0,0,0.3);border-radius:8px}
  /* small screens adjustments */
  @media (max-width:600px){
    .thread-label{width:70px;font-size:13px}
    .badge{font-size:12px;padding:4px 6px}
  }
</style>
</head>
<body>
<header>
  <div style="display:flex;flex-direction:column">
    <h1>Real-Time Multi-threaded Application Simulator</h1>
    <div class="meta">Kumar Abhinash (12501247) â€¢ Ajay Upadhyay (12528614) â€¢ Lovely Professional University</div>
  </div>
</header>

<div class="wrap">
  <!-- LEFT: Controls -->
  <div class="left">
    <div class="card">
      <label>Threading Model</label>
      <div class="row">
        <select id="modelSelect">
          <option>Many-to-One</option>
          <option>One-to-One</option>
          <option>Many-to-Many</option>
        </select>
        <label style="margin-left:6px" class="small">Scheduler</label>
        <select id="schedSelect" style="margin-left:6px">
          <option>RoundRobin</option>
          <option>FCFS</option>
          <option>Priority</option>
        </select>
      </div>

      <div class="sep"></div>

      <label>Create Thread</label>
      <div class="row" style="gap:6px">
        <input id="burstInput" type="number" placeholder="Burst (ticks)" value="6" style="width:120px" />
        <input id="prioInput" type="number" placeholder="Priority" value="1" style="width:90px" />
      </div>
      <div style="display:flex;gap:8px;margin-top:8px">
        <button id="addThreadBtn" class="primary">Add Thread</button>
        <button id="addRandomBtn">Add Random</button>
      </div>

      <div class="sep"></div>

      <label>Synchronization</label>
      <div class="row" style="gap:6px;margin-bottom:6px">
        <input id="sname" placeholder="Semaphore name" value="S1" style="width:120px" />
        <input id="sinit" type="number" placeholder="Init" value="1" style="width:70px" />
        <button id="createSema">Create</button>
      </div>
      <div class="row" style="gap:6px">
        <input id="mname" placeholder="Monitor name" value="M1" style="width:120px" />
        <button id="createMon">Create Monitor</button>
      </div>

      <div class="sep"></div>

      <label>Simulation Controls</label>
      <div class="row" style="margin-bottom:6px">
        <button id="playBtn" class="primary">Play</button>
        <button id="pauseBtn">Pause</button>
        <button id="stepBtn">Step</button>
        <button id="resetBtn" class="warn">Reset</button>
      </div>
      <div class="row" style="align-items:center;margin-top:8px">
        <label class="small">Quantum (ms)</label>
        <input id="quantum" type="number" value="300" style="width:100px;margin-left:6px" />
        <label class="small" style="margin-left:8px">Speed</label>
        <input id="speed" type="range" min="80" max="1000" value="300" style="flex:1;margin-left:6px" />
      </div>

      <div class="sep"></div>

      <label>Presets</label>
      <div style="display:flex;gap:8px;flex-wrap:wrap">
        <button id="preset1">Many-to-One Demo</button>
        <button id="preset2">Semaphore Pool</button>
        <button id="preset3">Producer/Consumer</button>
      </div>
    </div>

    <div class="card">
      <label>Save / Load Scenario</label>
      <div class="row" style="margin-bottom:8px">
        <button id="exportBtn">Export JSON</button>
        <input id="importFile" type="file" accept=".json" />
      </div>
      <div class="sep"></div>
      <label>Quick Tips</label>
      <ul class="small" style="margin:8px 0 0 18px;padding:0">
        <li>Use Step to debug tick-by-tick</li>
        <li>Use Many-to-One to see process-wide blocking</li>
        <li>Use semaphores to create realistic blocking</li>
      </ul>
    </div>

  </div>

  <!-- CENTER: Visualization -->
  <div class="center">
    <div class="card toolbar">
      <div style="display:flex;gap:12px;align-items:center;flex:1">
        <div><strong>Simulation</strong></div>
        <div class="muted">Tick: <span id="tickCounter">0</span></div>
        <div class="muted">Threads: <span id="countThreads">0</span></div>
        <div class="muted">Kernel threads: <span id="countKernel">0</span></div>
      </div>
      <div style="display:flex;gap:8px;align-items:center">
        <button id="clearLogs">Clear Logs</button>
      </div>
    </div>

    <div class="card lanes" id="lanesContainer" aria-live="polite">
      <!-- thread rows inserted here -->
      <div id="cpuArea" style="margin-bottom:12px">
        <label class="small" style="margin-bottom:6px;display:block">CPU / Kernel Threads</label>
        <div id="cpuSlots" class="cpu-box"></div>
      </div>

      <div id="threadsList"></div>
    </div>

    <div class="card">
      <label>Gantt (recent ticks)</label>
      <div class="muted" style="font-size:13px;margin-bottom:8px">Colors: ðŸŸ¢ Running â€¢ ðŸŸ¡ Ready â€¢ ðŸ”´ Blocked â€¢ âšª Terminated</div>
      <div id="logArea" class="log"></div>
    </div>
  </div>

  <!-- RIGHT: Resources & Info -->
  <div class="right">
    <div class="card">
      <label>Semaphores</label>
      <div id="semaList" class="resource"></div>
      <div class="sep"></div>
      <label>Monitors</label>
      <div id="monList" class="resource"></div>
    </div>

    <div class="card">
      <label>Thread Controls</label>
      <div id="threadControls" class="grid-2"></div>
    </div>

    <div class="card">
      <label>Event Log</label>
      <div id="events" class="log"></div>
    </div>
  </div>
</div>

<div class="footer card" style="margin:12px 16px">
  <div style="font-weight:700">Made for: Real-Time Multi-threaded Application Simulator</div>
  <div class="muted">Demonstrates thread models, scheduling, semaphores, and monitors â€” fully client-side.</div>
</div>

<script>
/*
  Real-Time Multi-threaded Application Simulator
  Single-file HTML/CSS/JS educational simulator.
*/

/* -------------------------
   Simulation Data Structures
   ------------------------- */
let nextTid = 1;
let tick = 0;
let running = false;
let timer = null;
let quantum = 300;
let model = 'Many-to-One';
let scheduler = 'RoundRobin';
let kernelThreads = 1; // for mapping pool in Many-to-Many
const threads = []; // user threads
const semaphores = {}; // {name: {value, queue:[]}}
const monitors = {}; // {name: {locked:false, owner:null, waitq:[]}}
const events = [];

/* Thread object:
  {
    id, state, burstRemaining, priority, history[], waitingFor: {type:'sema'|'monitor', name}
  }
*/

/* -------------------------
   Helpers & UI references
   ------------------------- */
const lanesEl = document.getElementById('threadsList');
const cpuSlotsEl = document.getElementById('cpuSlots');
const logEl = document.getElementById('logArea');
const eventsEl = document.getElementById('events');

function logEvent(msg){
  const time = tick;
  events.unshift(`[t=${time}] ${msg}`);
  if(events.length>200) events.pop();
  eventsEl.innerHTML = events.map(s=>`<div>${s}</div>`).join('');
}

/* -------------------------
   Simulation Engine
   ------------------------- */
function makeThread(burst=5, priority=1, name=null){
  const t = {
    id: nextTid++,
    name: name || `T${nextTid-1}`,
    state: 'Ready', // New, Ready, Running, Blocked, Terminated
    burstRemaining: burst,
    priority: priority,
    history: [],
    waitingFor: null,
    kernelSlot: null
  };
  threads.push(t);
  renderUI();
  logEvent(`Created ${t.name} (burst=${burst}, prio=${priority})`);
  return t;
}

function resetAll(){
  nextTid = 1;
  tick = 0;
  running = false;
  clearInterval(timer);
  timer = null;
  threads.length = 0;
  for(const k in semaphores) delete semaphores[k];
  for(const k in monitors) delete monitors[k];
  events.length = 0;
  renderUI();
  renderResources();
  updateStats();
}

function findReady(){
  return threads.filter(t=>t.state==='Ready');
}

function schedulerPick(){
  const ready = findReady();
  if(ready.length===0) return null;
  if(scheduler === 'FCFS') return ready[0];
  if(scheduler === 'Priority') {
    ready.sort((a,b)=> b.priority - a.priority || a.id - b.id);
    return ready[0];
  }
  // RoundRobin simulation: rotate by last run - we'll pick first ready to be simple
  return ready[0];
}

/* Apply model consequences when blocking occurs */
function applyModelOnBlock(blockingThread){
  if(model === 'Many-to-One'){
    // simulate entire process blocking: set non-terminated threads to Blocked
    threads.forEach(t=>{
      if(t.state !== 'Terminated'){
        if(t.id === blockingThread.id){
          t.state = 'Blocked';
          t.waitingFor = blockingThread.waitingFor;
        } else {
          if(t.state !== 'Terminated') t.state = 'Blocked';
        }
      }
    });
    logEvent(`(M2O) Process blocked due to ${blockingThread.name} waiting for ${blockingThread.waitingFor.type}:${blockingThread.waitingFor.name}`);
  } else if(model === 'One-to-One'){
    // only thread blocked -> handled elsewhere
  } else if(model === 'Many-to-Many'){
    // blocked thread returns kernel slot (if any)
    if(blockingThread.kernelSlot !== null){
      // free kernel slot
      blockingThread.kernelSlot = null;
      renderCPUSlots();
    }
  }
}

/* Semaphore operations */
function createSemaphore(name, init){
  if(!name) return;
  semaphores[name] = {value: init|0, queue: []};
  renderResources();
  logEvent(`Semaphore ${name} created (init=${init})`);
}
function sem_wait(name, tid){
  const s = semaphores[name];
  if(!s) return false;
  const t = threads.find(x=>x.id===tid);
  if(!t) return false;
  if(s.value > 0){
    s.value--;
    logEvent(`${t.name} acquired ${name}`);
    return true;
  } else {
    s.queue.push(t.id);
    t.state = 'Blocked';
    t.waitingFor = {type:'sema', name};
    applyModelOnBlock(t);
    logEvent(`${t.name} blocked on ${name}`);
    return false;
  }
}
function sem_signal(name){
  const s = semaphores[name];
  if(!s) return;
  if(s.queue.length>0){
    const wakeTid = s.queue.shift();
    const t = threads.find(x=>x.id===wakeTid);
    if(t){ t.state = 'Ready'; t.waitingFor = null; logEvent(`${t.name} unblocked from ${name}`); }
  } else {
    s.value++;
  }
  renderResources();
}

/* Monitor operations (simple) */
function createMonitor(name){
  monitors[name] = {locked:false, owner:null, waitq:[]};
  renderResources();
  logEvent(`Monitor ${name} created`);
}
function monitor_enter(name, tid){
  const m = monitors[name];
  const t = threads.find(x=>x.id===tid);
  if(!m || !t) return false;
  if(!m.locked){
    m.locked = true;
    m.owner = tid;
    logEvent(`${t.name} entered monitor ${name}`);
    return true;
  } else {
    m.waitq.push(tid);
    t.state = 'Blocked';
    t.waitingFor = {type:'monitor', name};
    applyModelOnBlock(t);
    logEvent(`${t.name} waiting to enter monitor ${name}`);
    return false;
  }
}
function monitor_exit(name){
  const m = monitors[name];
  if(!m) return;
  if(m.waitq.length>0){
    const nextTid = m.waitq.shift();
    m.owner = nextTid;
    const t = threads.find(x=>x.id===nextTid);
    if(t){ t.state='Ready'; t.waitingFor=null; logEvent(`${t.name} acquired monitor ${name}`) }
  } else {
    m.locked = false;
    m.owner = null;
  }
  renderResources();
}

/* -------------------------
   Tick / run loop
   ------------------------- */
function tickOnce(){
  tick++;
  document.getElementById('tickCounter').textContent = tick;
  // choose running threads per kernel capacity (for One-to-One maybe each user thread can run -> but sim limited)
  // We'll maintain kernelSlots count:
  let activeKernel = (model==='One-to-One') ? threads.filter(t=>t.state==='Ready' || t.state==='Running').length : (model==='Many-to-Many' ? Math.max(1, kernelThreads) : 1);
  // ensure activeKernel limit reasonable
  activeKernel = Math.min(activeKernel, 10);

  // if model is Many-to-One, only one can be running
  if(model === 'Many-to-One') activeKernel = 1;

  // get eligible threads for running (Ready)
  let runCandidates = threads.filter(t=>t.state==='Running' || t.state==='Ready');

  // If nothing to run, just add histories
  if(runCandidates.length === 0){
    threads.forEach(t=>{
      t.history.push(t.state);
      if(t.history.length>120) t.history.shift();
    });
    renderUI();
    return;
  }

  // assign running slots (simple):
  // 1) If someone is already Running, let them finish quantum (simulate by making them run one tick)
  // 2) Else pick by scheduler
  let runningNow = threads.filter(t=>t.state==='Running');
  if(runningNow.length < activeKernel){
    // fill slots
    while(runningNow.length < activeKernel){
      const pick = schedulerPick();
      if(!pick) break;
      pick.state = 'Running';
      runningNow.push(pick);
    }
  }

  // Execute work for running threads (1 unit)
  for(const t of threads){
    // history before update
    t.history.push(t.state);
    if(t.history.length>120) t.history.shift();
  }

  // copy running threads and process
  const toProcess = threads.filter(t=>t.state==='Running');
  for(const t of toProcess){
    // simulate performing 1 unit
    t.burstRemaining--;
    // random demo: some running threads attempt to acquire semaphores/monitors (disabled by default in stable)
    // If we want deterministic, comment randomness.
    // If burst completes
    if(t.burstRemaining <= 0){
      t.state = 'Terminated';
      t.waitingFor = null;
      logEvent(`${t.name} terminated`);
    } else {
      // For fairness/slice: put back to Ready for RR
      if(scheduler === 'RoundRobin'){
        t.state = 'Ready';
      } else {
        // FCFS or Priority will keep them Running until others
        t.state = 'Ready';
      }
    }
  }

  // occasionally auto-signal semaphores to show progress (demo)
  for(const name in semaphores){
    const s = semaphores[name];
    // if a queue exists and value==0, try to release occasionally
    if(s.queue.length > 0 && Math.random() < 0.05){
      sem_signal(name);
    }
  }
  // also try to release monitors occasionally for demo
  for(const name in monitors){
    const m = monitors[name];
    if(m.locked && Math.random() < 0.04){
      monitor_exit(name);
    }
  }

  renderUI();
  updateStats();
}

/* -------------------------
   UI Rendering
   ------------------------- */
function renderUI(){
  // CPU slots and threads
  renderCPUSlots();
  // thread list
  lanesEl.innerHTML = '';
  // threads sorted by id
  const sorted = threads.slice().sort((a,b)=>a.id - b.id);
  sorted.forEach(t=>{
    const row = document.createElement('div');
    row.className = 'thread-row';
    row.style.background = 'linear-gradient(90deg, rgba(255,255,255,0.01), rgba(255,255,255,0.005))';
    row.innerHTML = `
      <div class="thread-label">${t.name}</div>
      <div style="flex:1" title="State: ${t.state}; Burst: ${t.burstRemaining}; Prio: ${t.priority}">
        <div class="tiles" id="tiles-${t.id}"></div>
      </div>
      <div style="width:110px;text-align:right">
        <div class="small muted">State: ${t.state}</div>
        <div class="small muted">Burst: ${t.burstRemaining}</div>
      </div>
    `;
    lanesEl.appendChild(row);
    const tiles = document.getElementById(`tiles-${t.id}`);
    // render last 40 history entries
    const last = t.history.slice(-40);
    for(const s of last){
      const d = document.createElement('div');
      d.className = `tile state-${s}`;
      d.title = s;
      tiles.appendChild(d);
    }
    // ensure trailing filler to show future ticks
    for(let i=0;i<8;i++){
      const d = document.createElement('div');
      d.className = `tile`;
      d.style.opacity = 0.03;
      tiles.appendChild(d);
    }
  });

  // thread controls (per thread actions)
  renderThreadControls();
  renderResources();
  renderLogs();
}

function renderCPUSlots(){
  cpuSlotsEl.innerHTML = '';
  let slots = (model === 'Many-to-One') ? 1 : (model === 'One-to-One' ? Math.max(1, Math.min(threads.length, 8)) : Math.max(1, kernelThreads));
  document.getElementById('countKernel').textContent = slots;
  for(let i=0;i<slots;i++){
    const slot = document.createElement('div');
    slot.className = 'cpu-slot';
    // show which thread is running on this slot (naive mapping)
    const running = threads.find(t=>t.state==='Running');
    if(running){
      slot.innerHTML = `<div style="font-weight:700;color:#062122">${running.name}</div><div class="muted">Running</div>`;
    } else {
      slot.innerHTML = `<div class="muted">Idle</div>`;
    }
    cpuSlotsEl.appendChild(slot);
  }
}

function renderResources(){
  // semaphores
  const sl = document.getElementById('semaList');
  sl.innerHTML = '';
  for(const name in semaphores){
    const s = semaphores[name];
    const div = document.createElement('div');
    div.innerHTML = `<div><strong>${name}</strong><div class="small muted">val=${s.value} | queue=[${s.queue.map(id=>threads.find(t=>t.id===id)?.name||id).join(', ')}]</div></div><div class="badge">S</div>`;
    sl.appendChild(div);
  }
  // monitors
  const ml = document.getElementById('monList');
  ml.innerHTML = '';
  for(const name in monitors){
    const m = monitors[name];
    const ownerName = m.owner ? (threads.find(t=>t.id===m.owner)?.name || m.owner) : 'none';
    const div = document.createElement('div');
    div.innerHTML = `<div><strong>${name}</strong><div class="small muted">locked=${m.locked} owner=${ownerName} wait=[${m.waitq.map(id=>threads.find(t=>t.id===id)?.name||id)}]</div></div><div class="badge">M</div>`;
    ml.appendChild(div);
  }
}

function renderThreadControls(){
  const box = document.getElementById('threadControls');
  box.innerHTML = '';
  threads.forEach(t=>{
    const d = document.createElement('div');
    d.style.display = 'flex';
    d.style.flexDirection = 'column';
    d.style.gap = '6px';
    d.innerHTML = `
      <div style="display:flex;gap:6px;align-items:center;justify-content:space-between">
        <div style="font-weight:700">${t.name}</div>
        <div style="font-size:12px;color:var(--muted)">${t.state}</div>
      </div>
      <div style="display:flex;gap:6px">
        <button data-tid="${t.id}" class="btn-acquire">Acquire</button>
        <button data-tid="${t.id}" class="btn-release">Release</button>
        <button data-tid="${t.id}" class="btn-kill" style="background:#ff6b6b;color:white">Kill</button>
      </div>
    `;
    box.appendChild(d);
  });
  // attach listeners
  document.querySelectorAll('.btn-acquire').forEach(b=>{
    b.onclick = ()=>{
      const tid = Number(b.getAttribute('data-tid'));
      // open a small prompt to choose semaphore or monitor
      const choice = prompt('Acquire: type "S:name" for semaphore or "M:name" for monitor. Example: S:S1 or M:M1');
      if(!choice) return;
      if(choice.startsWith('S:')){
        const name = choice.slice(2);
        sem_wait(name, tid);
      } else if(choice.startsWith('M:')){
        const name = choice.slice(2);
        monitor_enter(name, tid);
      }
      renderUI();
    };
  });
  document.querySelectorAll('.btn-release').forEach(b=>{
    b.onclick = ()=>{
      const tid = Number(b.getAttribute('data-tid'));
      const choice = prompt('Release: type "S:name" to signal semaphore or "M:name" to exit monitor. Example: S:S1 or M:M1');
      if(!choice) return;
      if(choice.startsWith('S:')){
        const name = choice.slice(2);
        sem_signal(name);
      } else if(choice.startsWith('M:')){
        const name = choice.slice(2);
        monitor_exit(name);
      }
      renderUI();
    };
  });
  document.querySelectorAll('.btn-kill').forEach(b=>{
    b.onclick = ()=>{
      const tid = Number(b.getAttribute('data-tid'));
      const t = threads.find(x=>x.id===tid);
      if(!t) return;
      t.state = 'Terminated';
      logEvent(`${t.name} killed`);
      renderUI();
    };
  });
}

/* render logs */
function renderLogs(){
  logEl.innerHTML = events.slice(0,200).map(s=>`<div>${s}</div>`).join('');
}

/* update stats on header */
function updateStats(){
  document.getElementById('countThreads').textContent = threads.length;
}

/* -------------------------
   UI events binding
   ------------------------- */
document.getElementById('modelSelect').onchange = (e)=>{
  model = e.target.value;
  logEvent(`Model set to ${model}`);
  renderUI();
};
document.getElementById('schedSelect').onchange = (e)=>{
  scheduler = e.target.value;
  logEvent(`Scheduler set to ${scheduler}`);
};

document.getElementById('addThreadBtn').onclick = ()=>{
  const burst = Math.max(1, Number(document.getElementById('burstInput').value) || 5);
  const pr = Math.max(0, Number(document.getElementById('prioInput').value) || 1);
  makeThread(burst, pr);
  updateStats();
};
document.getElementById('addRandomBtn').onclick = ()=>{
  const burst = Math.floor(Math.random()*8)+2;
  const pr = Math.floor(Math.random()*3)+1;
  makeThread(burst, pr);
  updateStats();
};

document.getElementById('createSema').onclick = ()=>{
  const name = document.getElementById('sname').value.trim();
  const init = Math.max(0, Number(document.getElementById('sinit').value) || 0);
  if(!name){ alert('Enter name'); return; }
  createSemaphore(name, init);
};

document.getElementById('createMon').onclick = ()=>{
  const name = document.getElementById('mname').value.trim();
  if(!name){ alert('Enter name'); return; }
  createMonitor(name);
};

document.getElementById('playBtn').onclick = ()=>{
  if(running) return;
  running = true;
  quantum = Number(document.getElementById('quantum').value) || 300;
  const speed = Number(document.getElementById('speed').value) || 300;
  clearInterval(timer);
  timer = setInterval(tickOnce, speed);
  logEvent('Simulation started');
};
document.getElementById('pauseBtn').onclick = ()=>{
  running = false;
  clearInterval(timer);
  timer = null;
  logEvent('Simulation paused');
};
document.getElementById('stepBtn').onclick = ()=>{
  tickOnce();
};
document.getElementById('resetBtn').onclick = ()=>{
  if(confirm('Reset simulation?')) resetAll();
};
document.getElementById('clearLogs').onclick = ()=>{
  events.length = 0;
  renderLogs();
};

document.getElementById('preset1').onclick = ()=>{
  resetAll();
  model = 'Many-to-One';
  document.getElementById('modelSelect').value = model;
  scheduler = 'RoundRobin';
  document.getElementById('schedSelect').value = scheduler;
  createSemaphore('S1', 0);
  makeThread(6,1,'T1');
  makeThread(8,1,'T2');
  makeThread(4,1,'T3');
  logEvent('Loaded Many-to-One Demo');
  renderUI();
};
document.getElementById('preset2').onclick = ()=>{
  resetAll();
  model = 'Many-to-Many';
  document.getElementById('modelSelect').value = model;
  scheduler = 'FCFS';
  document.getElementById('schedSelect').value = scheduler;
  kernelThreads = 3;
  createSemaphore('SPOOL', 2);
  for(let i=0;i<6;i++) makeThread(6,1);
  logEvent('Loaded Semaphore Pool Demo');
  renderUI();
};
document.getElementById('preset3').onclick = ()=>{
  resetAll();
  model = 'Many-to-Many';
  document.getElementById('modelSelect').value = model;
  scheduler = 'RoundRobin';
  createMonitor('BUF');
  // producer/consumer: producers will "enter" monitor manually via controls or we simulate some events
  makeThread(6,1,'Producer1');
  makeThread(6,1,'Consumer1');
  makeThread(6,1,'Producer2');
  logEvent('Loaded Producer/Consumer Demo (use controls to Acquire/Release monitor BUF)');
  renderUI();
};

/* Save / Load */
document.getElementById('exportBtn').onclick = ()=>{
  const data = {threads, semaphores, monitors, model, scheduler, tick};
  const blob = new Blob([JSON.stringify(data,null,2)],{type:'application/json'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href = url; a.download = 'scenario.json'; a.click();
  URL.revokeObjectURL(url);
};
document.getElementById('importFile').onchange = (e)=>{
  const f = e.target.files[0];
  if(!f) return;
  const reader = new FileReader();
  reader.onload = (ev)=>{
    try{
      const data = JSON.parse(ev.target.result);
      resetAll();
      // restore basic structure
      if(data.semaphores) { for(const k in data.semaphores) semaphores[k]=data.semaphores[k]; }
      if(data.monitors) { for(const k in data.monitors) monitors[k]=data.monitors[k]; }
      if(Array.isArray(data.threads)){
        data.threads.forEach(t=> {
          // reconstruct thread shallowly
          const nt = makeThread(t.burstRemaining||5,t.priority||1,t.name||null);
          nt.state = t.state || 'Ready';
          nt.history = t.history || [];
        });
      }
      if(data.model) { model = data.model; document.getElementById('modelSelect').value = model; }
      if(data.scheduler) { scheduler = data.scheduler; document.getElementById('schedSelect').value = scheduler; }
      logEvent('Scenario imported');
      renderUI();
    }catch(err){ alert('Invalid JSON'); }
  };
  reader.readAsText(f);
};

/* initialize UI */
renderUI();
updateStats();

</script>
</body>
</html>
